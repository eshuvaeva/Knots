\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{ upgreek }
\usepackage{ stmaryrd }
\usepackage[pdftex]{graphicx}

\theoremstyle{theorem}
\newtheorem{theo}{Теорема}[section]
\newtheorem{lemma}[theo]{Lemma}
\newtheorem{examp}[theo]{Пример}
\theoremstyle{definition}
\newtheorem{defi}[theo]{Определение}
\newtheorem{prop}[theo]{Предложение.}


\title{project}
\author{elizshuvaeva }
\date{March 2015}

\newcounter{abc}
\setcounter{abc}{1}

\begin{document}

\section{\underline{Постановка задачи.}}

{Нестрого узел можно определить, как замкнутую несамопересекающуюся бесконечно тонкую нить в пространстве.
Теперь будет приведено строгое определение.}

\begin{defi}
%\textbf{Определение 1:}
Узел\textendashнепрерывное отображение из прямой в трехмерное пространство $f:{R^1\to R^3}$ периодичное с периодом $2\pi$ и такое, что разные точки каждого полуинтервала $\left [2\pi k,2\pi (k+1)^{}\right )$ переходят в разные точки пространства.
\end{defi}
{Узел можно деформировать, не склеивая и не размыкая нить. Такая деформация называется изотопией.\footnote[1]{Строгие определения изотопии и других понятий приведены в разделе "Основные математические понятия"} Помимо узлов можно рассматривать зацепления, представляющие собой несколько непересекающихся узлов(т.е. узел является частным случаем зацепления). К ним тоже можно применять изотопию. Зацепления, переводимые друг в друга, называются изотопными. Нахождения изотопных зацеплений\textendashодна из основных задач теории узлов. Найдены преобразования, последовательным применением конечного числа которых можно переводить зацепления друг в друга. Труднее доказывать неизотопность зацеплений. Для этого находят инварианты(величины, равные на изотопных зацеплениях). На картинках приведены простейший узел, называемый неузлом, и зацепление Хопфа.

Но удобнее работать не с самими зацеплениями, а с плоскими диаграммами\textendashих проекциями на плоскость. На зацеплении также можно выбирать направления обхода: из каждой точки зацепления можно "двигаться" в одну из двух сторон, но можно выбрать в какую именно. Зацепление, для которого установлено направление обхода называется ориентированным. На плоской диаграмме направление обхода указывается стрелкой. Ниже представлены примеры диаграмм ориентированных узлов. Именно при помощи плоских диаграмм подсчитывается скобка Кауффмана\footnote[2]{и скобка Кауффмана, и полином Джонса являются полиномами Лорана}, которая, не являясь инвариантом, позволяет посчитать полином Джонса\textendashинвариант для ориентированных зацеплений.

Цель программы\textendashподсчет скобки Кауффмана и полинома Джонса для различных зацеплений.}

\section{\underline{Метод решения.}}

{Программа принимает на вход характеристику зацепления(подробнее см. руководство пользователя), основанную на его плоской диаграмме. Кодирование зацеплений основано на кодировании графов с использованием списка соседей для каждой вершины. Поэтому дальше точки диаграмм, в которые проецируются 2 точки зацепления будут называться вершинами. После получения информации о зацеплении программа использует рекурсивный алгоритм подсчета скобки Кауффмана. Далее будет приведено описание этого алгоритма.

Пусть даны 3 плоских диаграммы зацеплений, которые совпадают вне кружков, а внутри выглядят так, как показано на рисунке. Тогда у первой диаграммы вершин на 1 больше, чем у последующих двух. Таким образом, диаграмму можно упростить, если "разомкнуть" пересечение на диаграмме способом A или способом B. Такие упрощения называются нулевым и первым разрешениями вершин соответственно. Можно заметить, что при повороте рисунка на 90 градусов разрешения меняются местами. Меняется и расположение пересекающихся частей нити в первом кружке. Поэтому для них рекурентные соотношения различны.}
\begin{defi}
%\textbf{Определение 1:}
Скобка Кауффмана\textendashполином, который определяется следующими соотношениями:
\newline{1)$<\emptyset> = 1$}
\newline{2)\footnote[3]{здесь $\cup$ обозначает несвязную сумму}$<L1\cup L2> = <L1>\cdot<L2>$}
\newline{3)$<L> = <L_{A}>- q\cdot<L_{B}>$}
\newline{4)$<L'> = <L_{B}>- q\cdot<L_{A}>$}
\end{defi}
{Программа применяет подходящее соотношение одной вершине данного зацепления, убирая ее двумя способами. К двум полученным зацеплениям применяется тот же алгоритм. Операция повторяется, пока все зацепления не будут упрощены до неузлов. Т.к. для неузла скобка Кауффмана определена, после этого можно осуществить подсчет для введенного зацепления. Следует заметить, что алгоритм заканчивается для любого зацепления с конечным числом вершин, т.к. на каждом шаге "стирается" одна из вершин.}

{Через скобку Кауффмана можно выразить полином Джонса, но чтобы это сделать, нужно знать ориентацию данного узла. На ориентированных узлах тоже можно рассматривать 2 вида пересечений:}

{Пусть в данном зацеплении число положительных перекрестков равно $n_{+}$, а число отрицательных перекрестков равно $n_{-}$. Теперь можно посчитать полином Джонса.}
\begin{defi}
%\textbf{Определение 2:}
\footnote[4]{Обычно определение полинома Джонса дается иначе, но пояснять подсчет удобно именно так}
полином Джонса\textendashполиномиальный инвариант зацепления, который выражается через скобку Кауффмана данного зацепления, таким образом:
\newline\normalsize{$J(L) = (q + q^{-1})^{-1}\left(\left(-1\right)^{n_{-}}q^{n_{+}-2n_{-}} \right)\cdot <L>$}
\end{defi}
{К полученной скобке Кауффмана применяются соответствующие операции и вычисляется полином Джонса.}

\section{\underline{Внешняя спецификация.}}
{Запускалась на компьютере с операционной системой Windows8 с помощью программы Python3.2. Предположительно работает на любом компьютере с установленным Python3.}

\section{\underline{Руководство пользователя.}}

{Программа запускается из  консоли. Для ввода данных нужна плоская диаграмма некоторого ориентированного зацепления. Сначала вводится число вершин в зацеплении, затем число несвязных\footnote[5]{т.е. неузлов, не соединенных ни с какой другой частью зацепления} неузлов, если они имеются. Растягивая нити можно сделать так, чтобы все вершины на диаграмме выглядели как L или L'(см. описание вычисления скобки Кауффмана). Из каждого перекрестка можно "двигаться" в одном из 4-х направлений(вправо вверх, влево вверх, влево вниз и вправо вниз) и каждое из направлений приводит в какую-то вершину(можно сказать, что у каждой вершины есть 4 соседа). Эти направления будут обозначены номерами 1,2,3,4 в соответствии с порядком, указанным в скобках. Далее вводятся характеристики вершин. Вершины характеризуются по очереди в порядке возрастания их номеров. }

{Характеристика вершины(все пункты предполагают ввод в одну строку через пробел, новый пункт соответствует новой строке):

1)В зависимости от того, к какому из видов неориентированных пересечений соответствует вершина, вводится + или - (+ соответствует L', - соответствует L). Потом определяется, к какому виду ориентированных перекрестков относится данная вершина, и вводится r для правого пересечения и l для левого.

2)Вводится номер 1-го(правого верхнего) соседа данной вершины, а также номер направления, в котором нужно идти от этого соседа к данной вершине.

3)Вводится номер 2-го(левого верхнего) соседа данной вершины, а также номер направления, в котором нужно идти от этого соседа к данной вершине.

4)Вводится номер 3-го(левого нижнего) соседа данной вершины, а также номер направления, в котором нужно идти от этого соседа к данной вершине.

5)Вводится номер 4-го(правого нижнего) соседа данной вершины, а также номер направления, в котором нужно идти от этого соседа к данной вершине.

Данные о каждой из вершин друг от друга не отделяются\textendashпросто характеристика новой вершины начинается с новой строки.



\section{\underline{Внутренняя спецификация.}}

{Создаются классы зацеплений и полиномов Лорана. 

1)Функции, применяемые к зацеплениям(сlass Link):

 inf(self,ar) позволяет получить информацию о данном зацеплении. Информация задается как последовательность характеристик вершин(см. руководство пользователя).

zero\_smoothing(self,vertex) получает на вход номер разрешаемой вершины, изменяет информацию о данном зацеплении таким образом, что новое зацепление соответствует получаемому из данного путем нулевого разрешения вершины с указанным номером. Возвращает новое зацепление.

 one\_smoothing(self,vertex) получает на вход номер разрешаемой вершины, изменяет информацию о данном зацеплении таким образом, что новое зацепление соответствует получаемому из данного путем первого разрешения вершины с указанным номером.  Возвращает новое зацепление.

 loop(self,vertex) тоже получает на вход номер вершины и проверяет есть ли у нее петли(т.е. есть ли она сама у себя в соседях). Возвращает последовательность номеров направлений, по которым из вершины можно сразу вернуться в нее же.

count\_right(self) и count\_left(self) подсчитывают число правых и левых вершин соответственно.

2)Функции, применяемые к полиномам Лорана(class LaurentPolynomial):

 \_\_init\_\_(self,min\_power,coeff) создает данный полином. На вход подается наименьшая степень и последовательность всех коэффициентов полинома, расположенных в порядке возрастания соответствующих им степеней(т.е. последний элемент соответствует наибольшей степени с ненулевым коэффициентом).

 \_\_add\_\_(self,other), \_\_mul\_\_(self,other)  и  \_\_pow\_\_(self,n) осуществляют сложение, умножение и возведение в степень полиномов Лорана соответственно. Для приведения подобных слагаемых при умножении используется вспомогательная  функция reduce(a), применяемая к промежуточной последовательности коэффициентов.

normal\_division(self) является вспомогательной для подсчета полинома Джонса, осуществляет деление на $(q + q^{-1})$

 printing(self) печатает полином в привычной записи.

3)Функции, осуществляющие вычисление полинома Джонса:

Kauffman(link) получает на вход объект класса зацеплений. Затем  проводит рекурсивный алгоритм, применяя функции разрешений и вычисляет скобку Кауффмана для данного зацепления(см. метод решения).

Jones(link)  получает на вход объект класса зацеплений. Применяет предыдущую функцию, использует функции подсчета числа различных вершин и вычисляет полином Джонса.



\section{\underline{Описание тестов.}}

Тест 1.

Для неузла:

Ввод:

0

1

Значение скобки Кауффмана:$q^{-1} + q^1$

Значение полинома Джонса: 1

Тест 2.

Для зацепления Хопфа:

Ввод:

2

0

+ r

2 4

2 3

2 2

2 1

+ r

1 4

1 3

1 2

1 1

Значение скобки Кауффмана:$q^{-2}+ 1 + q^2 + q^4$ 

Значение полинома Джонса: $q+q^5$
}

\section{\underline{Основные математические понятия.}}

{Здесь представлены некоторые факты, к которым ранее были даны отсылки.}
\begin{defi}
%\textbf{Определение 1:}
Пусть даны 2 узла: $K_1$ и K2.Рассмотрим отображение $F:R^1\times[0,1]\to R^3 $ такое, что $F(R^1\times{0}) = K1(R^1)$ , а $F(R^1\times{1}) = K2(R^1)$, при этом $\forall x \in [0,1] F(R^1\times{x})$ непрерывна. Такой переход от одного узла к другому называется плоской изотопией
\end{defi}


\begin{defi}
%\textbf{Определение 2:}
Плоская диаграмма зацепления\textendashортогональная проекция данного зацепления на плоскость, выбранную так,что:

1)проекция касательной к зацеплению для каждой точки зацепления является прямой(не вырождается в точку).

2)ни в какую точку плоскости не проецируется более двух точек зацепления

3)число точек плоскости, в которые проецируются 2 различные точки зацепления(такие точки называются перекрестками), конечно, а проекции касательных в 2-х точках, соответствующих перекрестку, не совпадают.

\end{defi}

{Но при плоской изотопии не могут возникать следующие изменения:}
{Такие преобразования называются движениями Рейдемейстера. Зная эти преобразования, можно сформулировать теорему Райдемейстера.}
\textbf{Tеорема Райдемейстера:}{Две диаграммы соответствуют изотопным узлам тогда и только тогда, когда их можно получить одну из другой с помощью конечного числа движений Рейдемейстера и плоских изотопий.}

\end{document}